<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_yr4_frc_nt">
  <title>Deploying Docker Apps</title>
  <body>
    <p>Docker images are deployed in much the same way as source code. </p>
    <p>To deploy directly from the Docker Hub or from specific Docker registry servers:
      <codeblock>$ helion push -n --docker-image my.registry.com/namespace/app-name:latest </codeblock>ALS
      will fetch the named image from the Docker Hub or specified registry server and deploy it.
      Imaged deployed like this are called Docker Apps. </p>
    <section>
      <title>Permission to Push</title>
        <p>Since arbitrary Docker images could potentially expose a root user and other escalated
      privileges,  Administrators will generally restrict the ability to push Docker images to:<ol
        id="ol_b5k_nrc_nt">
        <li> a trusted group of users in an Org with 'sudo' permissions enabled </li>
        <li>a trusted list of Docker images, namespaces, or registry servers</li>
        <li>a trusted group deploying from a trusted list </li>
      </ol>Depending on which restrictions the administrator has set, you may see an error
      describing the restriction when attempting to push as an unauthorized
      user:<codeblock> Error staging: Need 'allow_sudo' quota to stage and run a Docker app (400) </codeblock>Or
      if pushing an unauthorized image:
      <codeblock>Error staging: Docker image example/simple-server is not from an allowed registry (400) </codeblock></p></section>
    
    
    <section id="pushingDockerApps"><title>Pushing Docker Apps </title>Official images in the Docker Hub library can be
      specified by name, with or without a tag:
      <codeblock>$ helion push --docker-image django:1.8-python2</codeblock>Images from a particular
      user or organization can be specified with the namespace:
      <codeblock>$ helion push --docker-image cloudfoundry/lattice-app</codeblock> Images from a
      particular registry server require a fully qualified URL (without the protocol portion):
      <codeblock>$ helion push --docker-image registry.example.com/user/docker-app:latest</codeblock>
      If the registry you are using requires authentication, use the &lt;user>:&lt;pass>@&lt;host>
      format to specify the credentials:
      <codeblock>$ helion push --docker-image myname:mypass@reg.example.com/myname/myapp </codeblock>Administrators
      may save default credentials for specific servers in the Allowed Registries list. These are
      used by default for that registry server if present, but are overridden by any credentials you
      specify. <note>If the registry credentials contain the '@' or ':' characters, <xref
          href="https://en.wikipedia.org/wiki/Percent-encoding#Percent-encoding_reserved_characters"
          format="html" scope="external">URL encode</xref> the username or password strings as
        needed.</note></section>
    
    <section><title>Docker Apps and Data Services </title>Docker apps can be bound to data services
      just like staged apps. $VCAP_SERVICES and the URL-based environment variables are injected in
      the container and can be read by the application. See the <xref
        href="../../user/services/data-services.dita#topic19772">Data Services</xref> documentation
      for instructions on creating data service instances and binding them to applications. Docker
      apps do not have staging hooks:, so there is no opportunity to extract and reformat
      credentials into whatever format is expected by the Docker app. To work around this problem
      you can: <ol id="ol_bg1_csc_nt">
        <li>refactor the Docker app to consume the default service variables, or </li>
        <li>bind the new service to a temporary app (e.g. go-env or node-env) to find the service
          instance credentials, then set the environment variables the Docker app expects through
          the web console, the CLI client's <codeph>--env</codeph> option, or in the
            <i>manifest.yml</i> file. </li>
      </ol></section><section><title>Web Process and Exposed Ports </title>The <codeph>$PORT</codeph> environment
      variable exposed in staged apps is also available for Docker apps to use for web processes.
      For example, a Dockerfile might end with the line:
      <codeblock>ENTRYPOINT /usr/bin/python manage.py runserver 0.0.0.0:$PORT </codeblock>This will
      serve the web process on a port that has been automatically allocated. If the app's Dockerfile
      exposes a single port (e.g. <codeph>EXPOSE 8080</codeph>), that port will be forwarded
      instead. <note>If there is more than one port exposed in the Dockerfile, the app will fail to
        deploy.</note></section>
  </body>
</topic>
