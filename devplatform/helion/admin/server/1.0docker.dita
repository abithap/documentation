<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/topic.dtd" ><topic xml:lang="en-us" id="topic6449">
<title>HP Helion 1.0 Development Platform: Docker and Fence</title>
<prolog>
<metadata>
<othermeta name="layout" content="default"/>
<othermeta name="product-version" content="HP Helion Development Platform"/>
<othermeta name="product-version" content="HP Helion Development Platform 1.0"/>
<othermeta name="role" content="Application Developer"/>
<othermeta name="role" content="ISV Developer"/>
<othermeta name="role" content="Service Developer"/>
<othermeta name="role" content="Network Administrator"/>
<othermeta name="role" content="Systems Administrator"/>
<othermeta name="role" content="Security Engineer"/>
<othermeta name="role" content="Jayme P"/>
<othermeta name="product-version1" content="HP Helion Development Platform"/>
<othermeta name="product-version2" content="HP Helion Development Platform 1.0"/>
</metadata>
</prolog>
<body>
<p>
<!--PUBLISHED-->
 <!--./devplatform/helion/admin/server/1.0docker.md-->
 <!--permalink: /als/v1/admin/server/docker/--></p>
<p>

</p>
<p>Application Lifecycle Service's <xref href="../../../../devplatform/helion/admin/reference/1.0architecture.dita#architecture-dea" type="section"  >DEA role</xref>
runs Linux containers to isolate user applications during staging and at
runtime. Management of these application containers is handled by the
<codeph>fence</codeph> process, which in turn uses <xref href="http://docs.docker.io/en/latest/" scope="external" format="html" >Docker</xref> to create and destroy Linux containers on demand.</p>
<ul>
<li>
<xref type="section" href="#topic6449/modifying-or-updating-the-container-image">Modifying or Updating the Container Image</xref>
</li>
<li>
<xref type="section" href="#topic6449/admin-hooks">Admin Hooks</xref>
</li>
<li>
<xref type="section" href="#topic6449/creating-a-docker-registry">Creating a Docker Registry</xref>
</li>
</ul>
<p>Typically, admins will not have to work directly with Docker, but it is
available if needed to customize or create new container images.</p>
<section id="modifying-or-updating-the-container-image"> <title>Modifying or Updating the Container Image</title>
<p>Application containers are created from a base Docker image (a template
used to create Linux containers). Admins can create new images to add
specific software required by applications or update operating system
packages.</p>
<p>To create a new base image for Application Lifecycle Service to use for application
containers, perform the following steps <b>on all nodes running the DEA
role</b>:</p>
<ol>
<li>
<p>Start with an empty working directory:</p>

<codeblock>
<codeph>mkdir ~/newimg
cd ~/newimg
</codeph>
</codeblock>
</li>
<li>
<p>Check which image Application Lifecycle Service is currently using as an app container template:</p>

<codeblock>
<codeph>kato config get fence docker/image
helion/stack/alsek
</codeph>
</codeblock>
</li>
<li>
<p>Create a <xref href="http://docs.docker.io/en/latest/use/builder/" scope="external" format="html" >Dockerfile</xref>
which inherits the current Docker image, then runs an update or
installation command. For example:</p>

<codeblock>
<codeph>FROM helion/stack/alsek
RUN apt-get -y install libgraphite2-dev
</codeph>
</codeblock>

<ul>
<li>
<xref href="http://docs.docker.io/en/latest/use/builder#from" type="section" scope="external" format="html" >FROM</xref>:
inherits the environment and installed software from Application Lifecycle Service's
app image.</li>
<li>
<xref href="http://docs.docker.io/en/latest/use/builder#run" type="section" scope="external" format="html" >RUN</xref>:
specifies arbitrary commands to run before saving the image.</li>
<li>
<xref href="http://docs.docker.io/en/latest/use/builder#add" type="section" scope="external" format="html" >ADD</xref>: could
be used to copy files into the image.</li>
</ul>
</li>
<li>
<p>Build the image, setting the maintainer's name, and an image name:</p>

<codeblock>
<codeph>sudo docker build -rm -t exampleco/newimg .
</codeph>
</codeblock>
</li>
<li>
<p>Configure Application Lifecycle Service to use the new image:</p>
</li>
</ol>
<p>
  <b>Note</b>
</p>
<p>This step only needs to be done once, as the configuration change is
shared with all nodes:</p>
<codeblock>
  <codeph>kato config set fence docker/image exampleco/newimg
WARNING: Assumed type string
exampleco/newimg
</codeph>
</codeblock>
</section>
<section id="admin-hooks"> <title>Admin Hooks</title>
<p>If an administrator wants to run arbitrary commands in all application
containers, global admin hooks can be set to run immediately after
corresponding user-specified deployment hooks (pre-staging,
post-staging, pre-running) set in application 
<xref href="../../../../devplatform/helion/user/deploy/1.0manifestyml.dita" >manifest.yml</xref> files.</p>
<p>These hooks must be:</p>
<ul>
<li>plain bash scripts with the executable bit set (<codeph>chmod +x</codeph>)</li>
<li>named <i>pre-staging</i>, <i>post-staging</i>, or <i>pre-running</i>
</li>
<li>installed in <i>/etc/helion/hooks</i> within the Docker image</li>
</ul>
<p>For example, a pre-running admin hook might look like this:</p>
<codeblock>
  <codeph>#!/bin/sh
export PRE_RUN_DATE=`date`
export EXAMPLECO_KEY="3A0fwPwUftDu0FEzmhN8yJkvM1vS6A"
if [ -z "$NEW_RELIC_LICENSE_KEY" ]; then
  echo "setting default New Relic key"
  export NEW_RELIC_LICENSE_KEY="bdb9b44e8n4411d8bf39870f1919927d79cr0f1r"
fi
export HELION_HOOK_ENV=PRE_RUN_DATE,EXAMPLECO_KEY
sudo /usr/sbin/nrsysmond-config --set license_key=$NEW_RELIC_LICENSE_KEY
sudo /etc/init.d/newrelic-sysmond start
</codeph>
</codeblock>
<p>
  <b>Note</b>
</p>
<p>The <codeph>HELION_HOOK_ENV</codeph> environment variable is
needed to expose the specified variables in <codeph>helion ssh</codeph> sessions, the application container's crontab, and PHP
applications using the Legacy buildpack. This requirement may change in
subsequent releases.</p>
<p>The Dockerfile for creating the image (see <xref type="section" href="#topic6449/docker-modify-container">
<i>Modifying or Updating the
Container Image</i>
</xref> ) would use the ADD
directive to put a local <i>hooks</i> directory in the Docker image's
<i>/etc/helion/</i> directory:</p>
<codeblock>
  <codeph>FROM helion/stack/alsek
ADD hooks /etc/helion/hooks
</codeph>
</codeblock>
<p>The pre-running hook example above would require the addition of
<codeph>newrelic-sysmond</codeph> to the Docker image. A Dockerfile
enabling that might look like this:</p>
<codeblock>
  <codeph>FROM helion/stack/alsek

RUN echo deb http://apt.newrelic.com/debian/ newrelic non-free &gt;&gt; /etc/apt/sources.list.d/newrelic.list
RUN wget -O- https://download.newrelic.com/548C16BF.gpg | apt-key add -
RUN apt-get update
RUN apt-get install newrelic-sysmond
# The nrsysmond scripts are run with sudo

RUN echo "HELION ALL= NOPASSWD: /etc/init.d/newrelic-sysmond" &gt;&gt; /etc/sudoers
RUN echo "HELION ALL= NOPASSWD: /usr/sbin/nrsysmond-config" &gt;&gt; /etc/sudoers

ADD hooks /etc/helion/hooks
</codeph>
</codeblock>
</section>
<section id="creating-a-docker-registry"> <title>Creating a Docker Registry</title>
<p>The steps above will work with smaller clusters or micro clouds where
the creation of Docker images on each DEA can be done manually. On
larger clusters, you should set up a <xref href="http://blog.docker.io/2013/07/how-to-use-your-own-registry/" scope="external" format="html" >Docker
registry</xref>
as a central repository for your container templates.</p>
<ol>
<li>
<p>On the Core node of your cluster, pull the docker-registry
\&lt;https://index.docker.io/u/samalba/docker-registry/&gt; image from
the Docker index:</p>

<codeblock>
<codeph>sudo docker pull helion/docker-registry
</codeph>
</codeblock>
</li>
<li>
<p>Start the server:</p>

<codeblock>
<codeph>sudo docker run -d -p 5000 helion/docker-registry
f39d1b3f6fedc50e77875526352bd5a0f650a998dc1d7ca4e39c4a1eb8349e42
</codeph>
</codeblock>

<p>This returns the ID of the running registry server image. A shorter
container ID is also available via <codeph>docker ps</codeph>.
You can use either for the subsequent commands.</p>
</li>
<li>
<p>Use the ID to get the public facing port for the running image. For
example:</p>

<codeblock>
<codeph>sudo docker port f39d1b3f6fed 5000
0.0.0.0:49156
</codeph>
</codeblock>

<p>Your registry location is a combination of the API endpoint of your
cluster (i.e. <codeph>kato config get cluster endpoint</codeph>) combined with the port number returned by the command
above. For example:</p>

<codeblock>
<codeph>api.paas.example.com:49156
</codeph>
</codeblock>

<p>This registry location will be used to pull the images you create to
your DEA nodes.</p>
</li>
<li>
<p>Go through steps 1 - 3 <xref type="section" href="#topic6449/docker-modify-container">
<i>above</i>
</xref> to create
a Docker image file. When building the image, substitute the
registry location for the organization name used in step 4. For
example:</p>

<codeblock>
<codeph>sudo docker build -rm -t api.paas.example.com:49156/exampleco/newimg .
</codeph>
</codeblock>
</li>
<li>
<p>Push the newly built Docker image to the registry:</p>

<codeblock>
<codeph>sudo docker push api.paas.example.com:49156/exampleco/newimg
</codeph>
</codeblock>
</li>
</ol>
<p>
<b>Note</b>: The helion/stack/alsek and helion/base images (approximately 1.9GB) are pushed to the registry in addition to the new image. Make sure you have sufficient disk space available on the VM.</p>
<ol>
<li>
<p>
<b>On all DEA nodes</b>, pull the new image from the registry:</p>

<codeblock>
<codeph>sudo docker pull api.paas.example.com:49156/exampleco/newimg
</codeph>
</codeblock>
</li>
<li>
<p>Configure Application Lifecycle Service to use the new image:</p>

<codeblock>
<codeph>kato config set fence docker/image api.paas.example.com:49156/exampleco/newimg
WARNING: Assumed type string
api.paas.example.com:49156/exampleco/newimg
</codeph>
</codeblock>

<p>This step only needs to be done once, as the configuration change is
shared with all nodes.</p>
</li>
</ol>
</section>
</body>
</topic>
