<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_yw1_w3r_dt">
  <title>Create Your First Docker App</title>
  <body><section>
    <p>This Helion Development Platform release introduces the ability to deploy Docker images. This
      provides an alternative to the usual method of application deployment used by Cloud Foundry
      and Heroku, which is driven by buildpacks. This example takes an existing app and creates a
      Docker image that will run in ALS and take advantage of the provisioned services. </p></section><section><title>Start With a New "Stack" </title>
    <p>One of the advantages to using Docker is the ability to run different flavors of Linux. While ALS is based on Ubuntu 12.04 LTS, Docker images can be based on a
      different distro, such as Debian, CentOS, or even Alpine Linux images.</p><p>
   This example uses the openSUSE base image. Docker can compartmentalize
      system configuration into separate Docker layers, either by breaking up configuration steps
      into separate RUN directives in a single Dockerfile, or by creating separate images and
      chaining them together with the FROM directive at the top of each separate Dockerfile. This example includes both methods.</p></section><section><title>Update and Installing OS Packages</title>
        <p>The first thing this Dockerfile does is execute an update using the OS package manager. On openSUSE, this is done with <codeph>zypper</codeph>. </p>
          <codeblock>RUN
      \ zypper -n up \ &amp;&amp; zypper -n install python python-pip ca-certificates-mozilla \ vim
      git curl wget</codeblock>  
        <p>The openSUSE base image is intentionally minimal, so this also installs:
          <dl><dlentry>
            <dt>python</dt>
            <dd>Required for a Python web app </dd>
          </dlentry>
            <dlentry>
              <dt>python-pip</dt>
              <dd>For installing Python dependencies</dd>
            </dlentry>
            <dlentry>
              <dt>ca-certificates-mozilla</dt>
              <dd>Required by pip to use SSL </dd>
            </dlentry>
            <dlentry>
              <dt>vim</dt>
              <dd>Editor</dd>
            </dlentry><dlentry>
              <dt>git</dt>
              <dd>For cloning repos or installation from git sources </dd>
            </dlentry><dlentry>
              <dt>curl</dt>
              <dd>For general HTTP testing</dd>
            </dlentry><dlentry><dt>wget</dt><dd>For fetching of potentially useful things 
              </dd></dlentry>
          </dl></p>
<p>These installations provide the tools that are most likely necessary to script the installation of a Python application, try things out interactively in a locally running Docker container, or troubleshoot apps (through an ssh session).</p>
      
      <p>Notice that a couple of commands were chained together in the RUN statement.
      Every time a RUN command is used in a Dockerfile, it generates another image layer, and there's a hard
      limit of 127 layers in the current versions of Docker (the AUFS default limit). Bundling
      related commands together reduces the number of layers, helping ensure that the maximum is not exceeded.
      If there are relatively few layers, having the update and package install steps in separate RUN commands can take advantage of Docker's ability to
      use cached layers when rebuilding, which can speed up the build significantly.</p>
      </section><section><title>Build, test, and push Docker Images</title> 
      <p>The new "base+1" image layer is named 'troytop/opensuse-python'. </p><p>To build it, run this command in a directory that is empty
      except for the Dockerfile:</p><codeblock> $ sudo docker build --no-cache -t troytop/opensuse-python
      .</codeblock><p>In this case, <codeph>--no-cache</codeph> is used to ensure that the <codeph>zypper</codeph> update runs each time it builds, rather than relying on the cached image layer from previous builds.</p>
        <p>After the build completes, open an interactive shell and verify that it went as expected:</p>
<codeblock>sudo docker run -i -t troytop/opensuse-python /bin/sh sh-4.2# pip -V
      pip 1.5 from /usr/lib/python2.7/site-packages (python 2.7) sh-4.2# exit </codeblock> 
        <p>Note that if an app is to be shared, it should be pushed to the Docker Hub or other registry
      server:</p><codeblock>sudo docker push troytop/opensuse-python</codeblock></section>
    
    <section><title>The Next Layer: bottle-currency-suse</title>The Docker version of the example
      app (bottle-currency) is based on ubuntu:12.04, so the Dockerfile can be adapted to work with
      an opensuse-python image. Here's a breakdown:
      <codeblock>FROM troytop/opensuse-python MAINTAINER Troy Topnik &lt;troyt@activestate.com></codeblock>
      Nothing surprising here. Using a different container as a starting point and identifying
      myself as the maintainer.
      <codeblock>RUN useradd -d /home/www -m -s /bin/bash www 
USER www 
WORKDIR /home/www</codeblock>This
      creates a new user called 'www' and sets the active user and the working directory. If the app
      does not need to run as root, it should not.<codeblock>COPY . . </codeblock>Since the
      Dockerfile exists in the base directory of the bottle-currency sources, this command will
      recursively copy the contents of the current directory into the WORKDIR defined above.
      <codeblock>RUN pip install --user -r requirements.txt </codeblock>This installs the modules
      required by the application. With a staged application, this part would be handled by the
      buildpack. <codeblock>EXPOSE 8080</codeblock>Apps default to running on port 8080 if it
      doesn't see a $PORT environment variable, so we EXPOSE that port in the container with this
      command so that it's routed to an external port on the DEA host. The Stackato router will in
      turn be able to route to the app by forwarding external requests to this <i>hostname:port</i>.
      When running a staged app in Stackato, the application code or the Procfile will have to
      reference the $PORT variable that Stackato provides in the container. With Docker Apps we just
      have to make sure there's only one port exposed. CMD python wsgi.py Finally, we specify the
      command that starts the web process. In the buildpack world, this would be specified in a
      Procfile. With the Dockerfile ready, we repeat the same steps we did with the opensuse-python
      image to build, test, and push the image. The testing step is slightly different as we
      probably want to look at this with a browser. To do this we forward the container's port 8080
      to port 8000 on the host:
      <codeblock>sudo docker run -p 8000:8080 -t troytop/bottle-currency-suse</codeblock> Assuming
      we're doing this all on localhost, connecting to http://localhost:8000 with a browser will
      show the running web app. It won't work just yet. If you're trying this yourself, you'll see
      "An error occurred while contacting the server" and the conversion app won't actually
      function. That's because the app is looking for a Redis data service. There are a few ways to
      link Docker containers to other Docker containers providing databases, but we can handle this
      once it's deployed to Stackato. For now, we'll push our new image to the Docker Hub:
      <codeblock>sudo docker push troytop/bottle-currency-suse</codeblock></section><section><title>Attaching Services</title><p> The
      bottle-currency app looks for a Redis data service exposed by a REDIS_URL environment
      variable. Stackato injects environment variables (VCAP_SERVICES, _URL, etc. ) into the Docker
      containers to provide connection information for any services that have been bound to the app.
      This is the 12-factor way of doing things, and it's the way staged applications have always
      worked in Cloud Foundry. So, to deploy our app to Stackato:
      <codeblock>stackato push -n --docker-image troytop/bottle-currency-suse --mem 128 --as docker-currency</codeblock>
     This fetches the docker image from the Hub and deploys it (without a database yet). Next, we
      create a new Redis data service and bind it to the app:
      <codeblock>stackato create-service --plan free redis currency-data docker-currency</codeblock>
     This step will recreate the container with the necessary REDIS_URL variable in it. With your
      own code, you can find a number of ways to parse these environment variables and connect to
      the data services, but if you're trying to deploy something that someone *else* has already
      packaged as a Docker image, you might have to find creative ways to reformat the credentials
      provided by Stackato into variables that the app understands. The way to do this is to add
      another layer on top of the third-party image which parses the Stackato-provided environment
      variables, reformats them in a way the app will understand, and reiterates the CMD /
      ENTRYPOINT line from the original image.</p></section>
  </body>
</topic>
