<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_yym_nps_4t">
  <title>HP Helion <tm tmtype="reg">OpenStack</tm> 2.0: Enabling TLS for Public Endpoints</title>
  <body>

    <section id="intro">
      <p>
        <note><b>THIS DOCUMENT IS IN NO WAY READY FOR GA AND NEEDS MUCH UPDATING.</b></note>
      </p>
      
      <p>The Transport Layer Security (TLS) protocol, successor of SSL, provides the mechanisms to
        ensure authentication, non-repudiation, confidentiality, and integrity of user
        communications to the HP Helion OpenStack services from public endpoints.</p>
      <p>OpenStack endpoints are HTTP (REST) services providing APIs to other OpenStack services on the
        management network. All traffic to OpenStack services coming in on the public endpoints are
        secured using TLS connections.</p>
      <p/>



    </section>
    <section id="TLS_termination"><title>TLS termination for a public endpoint VIP </title> HP
      Helion OpenStack&#174; 2.0 supports fully qualified domain names (FQDN) for public endpoints.
      Open the following file and change components to tls-components in
      /home/stack/helion/my_cloud/definition/data/network_groups.yml load-balancers:
      <codeblock>   - provider: ip-cluster
     name: extlb                      # This is the external load balancer.
     external-name: myhelion.test     # change this to a resolvable FQDN
     tls-components:
        - default
     roles:
        - public
          cert-file: my-public-cert   # this cert should match the FQDN for authenticated TLS to work</codeblock>
      What this configuration means: <dl>
        <dlentry>
          <dt>name: extlb</dt>
          <dd>The external Loadbalancer (LB)</dd>
        </dlentry>
        <dlentry>
          <dt>external-name:</dt>
          <dd>This name will be used in place of the external VIP address. This name can be an FQDN.
            This will be registered in the public endpoints of the services. The myhelion.test has
            to be</dd>
        </dlentry>
        <dlentry>
          <dt>tls-components:</dt>
          <dd>This list of services will be put behind TLS. Note this is only being done for the LB
            in question, which is the external LB. The components in ‘default’ are those services
            defined under service-components in data/control_plane.yml. If you want to have a finer
            granularity, you can replace default with a list of individual components, as in:
            <codeblock>tls-components: - 'horizon' </codeblock>
          </dd>
        </dlentry>
        <dlentry>
          <dt>cert-file:</dt>
          <dd> the default my-public-cert is already part of the playbook but you can specify your
            own name. When you specify your own you also need to have the certificate copied in
            ~/helion/my_cloud/config/tls/certs on the deployer. </dd>
        </dlentry>
      </dl>
      <note>Do not enable TLS to the internal loadbalancer. </note></section>
    <section id="configure_cipher">
      <title>Configuring the cipher suite for public endpoints</title> We have set the default
      cipher suite to be: <codeph>HIGH:!aNULL:!eNULL:!DES:!3DES</codeph>. This is a recommended
      setting from the <xref
        href="http://docs.openstack.org/security-guide/secure-communication/introduction-to-ssl-and-tls.html"
        format="html" scope="external">OpenStack documentation site</xref>.   You may override this.
      Open <b>config/haproxy/defaults.yml</b> and edit it. The parameters would be under
      haproxy_globals list.
      <codeblock>- "ssl-default-bind-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"
- "ssl-default-server-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"</codeblock>
      Make the changes as needed. It's best to keep the two options identical. </section>
    <section id="new_cert"><title>Installing a new certificate</title> You should obtain your own
      certificate and install it in the cloud. When this certificate is ready, please do the
      following and rerun the config-processor and reconfigure. Copy the certificate (containing
      both public and private key) to <b>helion/my_cloud/config/tls/certs/ directory</b> </section>
    <section>Update the new certificate filename in cert-file in
        <b>helion/my_cloud/definition/data/network_groups.yml</b>. <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-clean.yml</codeblock>
      <p>Commit your changes to git.</p>
      <codeblock>cd ~/helion/hos/ansible
git add -A
git commit -m "My config or other commit message"</codeblock>
      <p>Rerun the config processor</p>
      <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-run.yml</codeblock>
    </section>
    
    <section><title>Testing public endpoints</title> The following write up is for people trying to
      test the public endpoints using the bundled test certificate with a virtual cloud. There are
      three usecases here. <ul id="ul_z51_djg_rt">
        <li>Access public endpoints from the deployer </li>
        <li>Access public endpoints from the machine hosting the virtual cloud </li>
        <li>Access public endpoints from a machine other than the machine hosting the virtual cloud
        </li>
      </ul>All these cases reduce to the following steps <ol id="ol_ay1_djg_rt">
        <li>Have a name resolver for myhelion.test - It could /etc/hosts or dnsmasq reading from a
          hosts file </li>
        <li>Install the ca certificate that signed the test server certificate. This file can be
          found in the deployer under roles/tls-trust/files/frontend_cacert.pem. This file is not
          symlinked via the config directory to customers because we generally don't need the CA
          certificate signing the external certificate inside the cloud. </li>
      </ol>
      <b>Accessing public endpoints from the deployer</b>
      <ol id="ol_q1b_djg_rt">
        <li>Make an entry for the vip inside the /etc/hosts file pointing to myhelion.test </li>
        <li>run the playbook to install ca certificate.
          <codeblock>ansible-playbook -i hosts/verb_hosts tls-trust-deploy.yml</codeblock></li>
      </ol>
      <b>Accessing public endpoints from the machine hosting the virtual cloud</b>
      <ol id="ol_ddb_djg_rt">
        <li>Make an entry for the vip inside the /etc/hosts file pointing to myhelion.test </li>
        <li>Copy the CA certificate from the
          deployer:/home/stack/scratch/ansible/next/hos/ansible/roles/tls-trust/files/frontend_cacert.pem
          to /usr/local/share/ca-certificates/helion-ca.crt </li>
        <li>Run <codeblock>sudo update-ca-certificates --fresh</codeblock></li>
      </ol>
      <b>Accessing public endpoints from a machine other than the machine hosting the virtual
        cloud</b>
    </section>
    <section>Start by repeating what was done for the machine hosting the virtual cloud. But this
      time your /etc/hosts entry for myhelion.test should point to the IP address of the host
      running the virtual cloud. After this you need to have something tunnelling the packets to the
      VIP. This is easily accomplished with haproxy in tunnel mode. (mode tcp). But you need to have
      a stanza for every open port. But the stanzas are quite generic and can be scripted. For
      example if I want to do 'nova list' I may need port 5000 (keystone) and port 8774 (nova-api),
        <ol id="ol_ofb_djg_rt">
        <li>Install haproxy with apt-get </li>
        <li>Open /etc/haproxy/haproxy.cfg and append the following sections to the existing content:
          <codeblock>listen keystone-5000
      option ssl-hello-chk
      mode tcp
      bind 16.25.10.10:5000
      server keystone-5000 192.168.245.10:5000 check inter 2000 rise 2 fall 5
      listen nova-8774
      option ssl-hello-chk
      mode tcp
      bind 16.25.10.10:8774
      server nova-8774 192.168.245.10:8774 check inter 2000 rise 2 fall 5
      
      16.25.10.10 is the host running the virtual cloud
      192.168.254.10 is the VIP</codeblock></li>
      </ol> One way to generate the list of all public ports behind TLS is to run 'grep "ssl crt"
      /etc/haproxy/haproxy.cfg' from a controller. </section>
  </body>
</topic>
