<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_u3v_1yz_ct">
  <title>Using the local git repository for configuration</title>
  <body>
    <p>In HP Helion OpenStack 2.0 versions, a local git repository is used to track configuration changes and for the config processor to </p>
    <p> # Design of the (customer-side) git layout </p>
    <p>It's a requirement that we have some way to merge changes that we deliver as an "upstream" to
      our customers, and to manage their site configuration. For this purpose, we've settled on a
      simple idiomatic use of git. The lifecycle we envisage is described below; how that is seen by
      the customer (or developer) follows each section. For each stage we finally give the technical
      details should a user (or developer) want to look under the hood (or tinker with the
      contents). </p>
    <p>## Initialisation On a new deployment of a never-before-seen system, the initial stage
      requires the preparation of a git repository under ~/helion. </p>
    <p>### User experience </p>
    <p>The deployer provisioning runs the hlm-init-deployer script automatically; this calls
      ansible-playbook -i hosts/localhost git-00-initialise.yml ### Technical result The ~/helion
      directory is initialised as a git repo (if it's empty). That is prepared with four empty
      branches: hos, site, ansible and cp-persistent. The use of each of these branches is detailed
      below. </p>
    <p>## Receive a new Helion drop </p>
    <p>A customer receives a new deployer image. They have to merge any configuration changes into
      their own config; this is a manual step, although the standard git tools may be brought to
      bear to achieve this. </p>
    <p>### User experience </p>
    <p>The deployer provisioning runs the following playbooks: ansible-playbook -i hosts/localhost
      deployer-init.yml ansible-playbook -i hosts/localhost git-01-receive-new.yml the latter of
      which puts the new content directly onto the 'hos' branch. That branch is merged to the 'site'
      branch; the merge may require a manual review and commit by the customer. </p>
    <p>### Technical result </p>
    <p>After the import step, there is a new commit on the 'hos' branch with the latest upstream
      deployer content on it. This looks much like the content of the ~/helion directory as it was
      prior to the introduction of the git workflow. The ~/helion repo will be checked out to the
      'site' branch and the results of the merge left in place for review by the user. ## User
      cycles on configuration The user edits their configuration until they are happy with it on the
      'site' branch in their ~/helion repository. </p>
    <p>### User experience </p>
    <p>The CI system simply copies a configuration unconditionally to the
      ~/helion/my_cloud/definition directory and commits it there. Any configuration changes must be
      committed prior to continuing; the "config-processor-run.yml" script will abort with a message
      to that effect if that condition is not met. </p>
    <p>### Technical result </p>
    <p>The 'site' branch gets a configuration under the my_cloud/definition subdirectory. </p>
    <p>## Run the configuration processor </p>
    <p>The configuration processor takes as input the user's configuration, and also any persistent
      data saved from a previous run. (That data contains things such as the allocation of roles to
      servers, etc.) It produces as output a set of ansible variable settings (amongst other input
      to the ansible playbooks); and may update its persistent state. </p>
    <p>### User experience </p>
    <p>The user executes ansible-playbook -i hosts/localhost config-proessor-run.yml as before;
      however, the CP persistent state and the ansible outputs now reside on different branches, not
      immediately visible to the user. If the CP run was unsuccessful, the user may continue to edit
      and commit to their 'site' branch. An "--amend" commit is acceptable here. </p>
    <p>### Technical result </p>
    <p>A scratch directory is prepared to run the CP in, to wit, ~/scratch/cp. The site
      configuration is checked out into it. Atop this is laid any saved persistent state for the CP,
      which is taken from the head of the 'cp-persistent' branch. Updated CP persistent data is
      temorarily stashed to the 'staging-cp-persistent' branch; ansible output to the
      'staging-ansible' branch. The reason for this is that, until a deployment actually occurs,
      there is no guarantee that any additional CP state accruing will gain any measure of
      real-world semantics by being used for a deployment. We always reset the inputs to the CP to
      the last *deployed* persistent state. </p>
    <p>## Prepare and run a deployment </p>
    <p>A deployment area is prepared to run an update or a deploy from. At this point we consider
      the staged output from the CP to be 'live' - promoting the commits to the long-lived 'ansible'
      and 'cp-persistent' branches. </p>
    <p>### User experience </p>
    <p>The user readies a deployment area by running ansible-playbook -i hosts/localhost
      ready-deployment.yml from the ~/helion/hlm/ansible directory. This will prepare a scratch
      directory with the appropriate contents in it under "~/scratch/ansible/next/hlm/ansible". The
      deployment may be continued via: cd ~/scratch/ansible/next/hlm/ansible ansible-playbook -i
      hosts/verb_hosts site.yml </p>
    <p>### Technical details </p>
    <p>The tip of the "staging-ansible" and "staging-cp-persistent" branches are laid down upon the
      "ansible" and "cp-persistent" branches; the former pair are then deleted. The tip of "site",
      "ansible", and "cp-persistent" are tagged with a time-stamped tag to indicate when the
      deployment was readied. Two working areas are laid out underneath ~/scratch/ansible. The
      "next/" directory holds the latest deployment tree. Alongside this, the "last/" directory
      holds the previous tree - that is, the one constructed from the previous timestamps. The
      thinking behind this is that, whilst we currently don't use the former ansible state for
      upgrades, that any topology change will require ansible to know where services _used_ to run
      in order to successfully find and disable them. At the moment, the best use of this directory
      is as a convenient tree to run "diff" from. </p>
  </body>
</topic>
